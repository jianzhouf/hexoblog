<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[reacthook]]></title>
    <url>%2Fhexoblog%2F2019%2F06%2F27%2Freacthook%2F</url>
    <content type="text"><![CDATA[react Hooks 初探useState1const [state, setState] = useState(initialState); state的初始值可通过第一个参数initialState赋值数组的解构得到state和更新函数setState useEffect12345678910111213// didUpdate更新回调，deps 监听变量数组useEffect(didUpdate, deps)useEffect(()=&gt;&#123; console.log("componentDidMount"); return ()=&gt;&#123; console.log("componentWillUnmount"); &#125;&#125;)useEffect(()=&gt;&#123; console.log("componentDidUpdate");&#125;,[state]) useMemo/useCallback用作性能优化 12]]></content>
  </entry>
  <entry>
    <title><![CDATA[ios兼容问题]]></title>
    <url>%2Fhexoblog%2F2019%2F05%2F29%2Fiosfix%2F</url>
    <content type="text"><![CDATA[ios 混合webview 兼容问题ios键盘收起导致页面上移产生原因： 为了用户体验，input聚焦时，使得body的scrollTop加上了键盘的高度，导致页面上移； 12345678910111213if (device.ios()) &#123; let timer window.addEventListener("focusin", (e) =&gt; &#123; if (timer) &#123; clearTimeout(timer) &#125; &#125;) window.addEventListener("focusout", (e) =&gt; &#123; timer = setTimeout(() =&gt; &#123; e.target.scrollIntoView() &#125;, 200) &#125;)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端遮罩层问题]]></title>
    <url>%2Fhexoblog%2F2019%2F05%2F21%2Fmask%2F</url>
    <content type="text"><![CDATA[移动端遮罩层问题移动端 ios safari 方法1body加上overflow:hidden.PC可以实现问题：在移动端 会有滚动穿透问题定义：移动端弹出fixed弹窗的话，在弹窗上滑动会导致下层的页面跟着滚动，这个叫 “滚动穿透” 方法2body加上 position:fixed解决了滚动穿透问题新的问题：滚动位置丢失！页面会回到顶部！修复方法：123456789101112131415//以下vue 的代码实现 通过 遮罩层的显示隐藏 切换body 的样式 watch: &#123; visible: function(val) &#123; if (val) &#123; this.top = document.body.scrollTop || document.documentElement.scrollTop; document.body.style.position = "fixed"; document.body.style.top = -this.top + "px"; &#125; else &#123; document.body.style.position = ""; document.documentElement.scrollTop = document.body.scrollTop = this.top; &#125; &#125; &#125;// 注意： 由于fixed 的改变了body的样式 ， 请加上 body&#123;width: 100%&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[优秀的三方库收集]]></title>
    <url>%2Fhexoblog%2F2019%2F05%2F09%2Flib%2F</url>
    <content type="text"><![CDATA[html2canvas 可做截屏功能 可做某个片段／图片的 特效功能，例如 google 灭霸特效 123html2canvas(document.body).then(function(canvas) &#123; document.body.appendChild(canvas);&#125;); chance 随机字符串，数字等的极简主义生成器 编写自动化测试 12chance.string()chance.integer(&#123; min: -20, max: 20 &#125;) Lodash Lodash通过处理数组，数字，对象，字符串等麻烦使得JavaScript更容易]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-redux]]></title>
    <url>%2Fhexoblog%2F2019%2F04%2F11%2Freact-redux%2F</url>
    <content type="text"><![CDATA[关于redux三大原则 单一数据源 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 State 是只读的 唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 使用纯函数来执行修改 为了描述 action 如何改变 state tree ，你需要编写 reducers。 简单的redux 实例12345678910111213141516171819202122import &#123;createStore&#125; from "redux"const ADD_TODO = "ADD_TODO"/*action*/function addTodo ()&#123; return &#123; type: ADD_TODO, &#125;&#125;/*reducer*/function todos(state=&#123;index:1&#125;, action)&#123; switch(action.type)&#123; case ADD_TODO: return &#123;...state, index: state.index+1&#125; default: return state &#125;&#125;const store = createStore(todos)store.subscribe(()=&gt;&#123; store.getState() // &#123;index:2&#125;&#125;)store.dispatch(addTodo()) react-redux 异步action 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &#123;createStore,applyMiddleware&#125; from "redux"import thunkMiddleware from "redux-thunk"const ADD_TODO = "ADD_TODO"/*action*/function addTodo ()&#123; return &#123; type: ADD_TODO, &#125;&#125;//利用 thunkMiddleware 让 dispach可以识别函数function asyncAddTodo()&#123; return function (dispatch)&#123; setTimeout(()=&gt;&#123; dispatch(addTodo()) &#125;,2000) &#125;&#125;/*reducer*/function todos(state=&#123;index:1&#125;, action)&#123; switch(action.type)&#123; case ADD_TODO: return &#123;...state, index: state.index+1&#125; default: return state &#125;&#125;const store = createStore(todos,applyMiddleware(thunkMiddleware))//使用react-redux//入口文件，&lt;Provider&gt; 来 魔法般的 让所有容器组件都可以访问 store，而不必显示地传递它import &#123;Provider&#125; from "react-redux"ReactDOM.render(&lt;Provider store=&#123;store&#125;&gt;&lt;App /&gt;&lt;/Provider&gt;, document.getElementById('root'));//利用connect 生成容器组件 代替 store.subscribe， 这个方法做了性能优化来避免很多不必要的重复渲染import &#123;connect&#125; from "react-redux"import &#123;asyncAddTodo,addTodo&#125; from "./index"export default connect((state,ownProps)=&gt;&#123;return &#123; index: state.index&#125;&#125;,(dispatch)=&gt;(&#123; addTodo: ()=&gt;&#123; dispatch(addTodo()) &#125;, asyncAddTodo: ()=&gt;&#123; dispatch(asyncAddTodo()) &#125;&#125;))(App); redux 源码解析createStore 源码解析createStore1234567891011121314151617181920// reducer: 响应 actions 返回新的 state// preloadedState: 初始state// enhancer: 利用 applyMiddleware 对store 增强createStore(reducer, preloadedState, enhancer)// createStore 执行时 初始化一次statedispatch(&#123; type: ActionTypes.INIT &#125;)//`createStore的返回值`return &#123; dispatch, /** * 触发一个action， * 执行 currentState = currentReducer(currentState, action)，更新state * 执行所有的listeners */ subscribe, // 添加监听，状态变化时执行所有的listeners getState, // return currentState replaceReducer, // 替换成新的reducer [$$observable]: observable // 定义一个观察者对象，须有next 接口方法&#125; combineReducers 源码解析1234567891011121314151617181920212223242526export default function combineReducers(reducers) &#123; const reducerKeys = Object.keys(reducers) // 对所有的reducers key 进行收集 ... return function combination(state = &#123;&#125;, action) &#123; let hasChanged = false const nextState = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] // reducer的key 指向的 单独的state const nextStateForKey = reducer(previousStateForKey, action) // 以reducer的key 存储 每一个reducer 维护的state nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125; applyMiddleware 源码解析中间件 就是将 store的dispatch进行增强,使得可以接受一个函数，promise对象等，例如 redux-thunk 、redux-promise12345678910111213141516171819export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) //提供了 store 的getState 和 dispath 的方法 const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 提供一个增强的dispatch方法 dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125; react-redux 源码简单分析Provider123456789101112131415161718class Provider extends Component &#123; constructor(props) &#123; super(props) ... this.state = &#123; store, // redux 创建的 store // provider 提供的一个 可添加订阅的 方法 // subscription 本身对 store.subscribe 监听 subscription &#125; &#125; render()&#123; return &lt;Context.Provider value=&#123;this.state&#125;&gt; &#123;this.props.children&#125; &lt;/Context.Provider&gt; &#125;&#125; Connect123456789101112131415161718192021222324252627282930313233343536373839404142434445464748export default function connectAdvanced(selectorFactory, &#123;...&#125;)&#123; ... const checkForUpdates = ()=&gt;&#123; ... // If the child props haven't changed, nothing to do here - cascade the subscription update // props 不变 if (newChildProps === lastChildProps.current) &#123; if (!renderIsScheduled.current) &#123; notifyNestedSubs() &#125; &#125; else &#123; // Save references to the new child props. Note that we track the "child props from store update" // as a ref instead of a useState/useReducer because we need a way to determine if that value has // been processed. If this went into useState/useReducer, we couldn't clear out the value without // forcing another re-render, which we don't want. lastChildProps.current = newChildProps childPropsFromStoreUpdate.current = newChildProps renderIsScheduled.current = true // If the child props _did_ change (or we caught an error), this wrapper component needs to re-render // 如果 props 改变 组件重新render forceComponentUpdateDispatch(&#123; type: 'STORE_UPDATED', payload: &#123; latestStoreState, error &#125; &#125;) &#125; ... &#125; // Actually subscribe to the nearest connected ancestor (or store) // didStoreComeFromProps ? null : contextValue.subscription context 提供的 subscription // subscription.onStateChange = checkForUpdates // 添加订阅 subscription.trySubscribe() // Pull data from the store after first render in case the store has // changed since we began. // checkForUpdates() &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack配置]]></title>
    <url>%2Fhexoblog%2F2019%2F03%2F27%2Fwebpack%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[记录webpack 配置过程 webpack 参数配置入口 entryloader loader 用于对模块的源代码进行转换。类似于其他构建工具中任务(task) jsx 语法@babel/corebabel-loader@babel/preset-react 引入antd需要开启 less-loader options: {javascriptEnabled: true} 箭头函数问题transform-class-properties 动态导入dynamic-import-webpack]]></content>
  </entry>
  <entry>
    <title><![CDATA[js继承]]></title>
    <url>%2Fhexoblog%2F2019%2F03%2F26%2Fextend%2F</url>
    <content type="text"><![CDATA[es5实现js继承的几种方式 js继承1234567//父类构造函数function Person(name)&#123; this.name = name&#125;Person.prototype.say = function (word)&#123; console.log(word)&#125; 原型链继承123456789101112//子类function Man()&#123; this.sex = "male"&#125;// 子类原型指向父类实例Man.prototype = new Person("jack")Man.prototype.constructor = Man;var man = new Man()console.log(man.name) //jackconsole.log(man.sex) //male// man 的原型链上 找到 Person.prototypeconsole.log(man instanceof Person) //true 特点 实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）缺点 新实例无法向父类构造函数传参 继承单一 所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！） 组合继承（组合原型链继承和借用构造函数复制父类构造函数属性）（常用）123456789101112function Man(name)&#123; //复制父类构造函数的属性 Person.call(this,name); this.sex = "male"&#125;//继承父类原型Man.prototype = new Person()Man.prototype.constructor = Man;var man = new Man("jack")console.log(man.name) //jackconsole.log(man.sex) //maleconsole.log(man instanceof Person) //true 特点 可以继承父类原型上的属性，可以传参，可复用 每个新实例引入的构造函数属性是私有的缺点 调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数 寄生组合式继承1234567891011121314151617181920// 子类构造函数 复制 父类构造函数 的属性function Man(name)&#123; Person.call(this,name) this.sex = "male"&#125;// 空函数Ffunction F()&#123;&#125;// 把F的原型指向 父类的原型F.prototype = Person.prototype// 让子类的原型 指向F实例 从而利用原型链 继承父类的原型Man.prototype = new F()// 把Man 原型的 构造函数 修复为 ManMan.prototype.constructor = Manvar man = new Man("jack")console.log(man.name)console.log(man.sex)console.log(man instanceof Man)console.log(man instanceof Person)man.say("hello") 修复了 组合继承调用两次父类构造函数的问题 代码简化123456789101112131415161718function Person(name)&#123; this.name = name&#125;Person.prototype.say = function (word)&#123; console.log(word)&#125; function inherits(Child, Parent)&#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125;function Man(name)&#123; Person.call(this,name) this.sex = "male"&#125;//实现继承inherits(Man,Person) 注意点1Man.prototype.constructor = Man 由于Man的protoType被Person实例覆盖 所以Man.prototype.constructor 会指向 Person构造函数 为了防止类似 (实例)man.proto.constructor() 等显式调用 返回的错误指向问题 The constructor property makes absolutely no practical difference to anything internally. It’s only any use if your code explicitly uses it. For example, you may decide you need each of your objects to have a reference to the actual constructor function that created it; if so, you’ll need to set the constructor property explicitly when you set up inheritance by assigning an object to a constructor function’s prototype property, as in your example.]]></content>
      <tags>
        <tag>继承</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise 异步应用]]></title>
    <url>%2Fhexoblog%2F2019%2F03%2F26%2Fpromise%2F</url>
    <content type="text"><![CDATA[Promise 异步应用Promise 例子Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。 123456789101112131415161718192021function myPromise(value, time, status) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; //用 console.log(value); if (status) &#123; resolve(); &#125; else &#123; reject(value); &#125; &#125;, time) &#125;)&#125;myPromise(1, 500, true).then(() =&gt; &#123; return 1;&#125;).then(() =&gt; &#123; return myPromise(3, 1500, true);&#125;).then(() =&gt; &#123; return myPromise(4, 1500, false);&#125;).catch((err) =&gt; &#123; console.log(err);&#125;) Promise原型方法Promise.prototype.catch(onRejected) 添加一个否定(rejection) 回调到当前 promise, 返回一个新的promise。如果这个回调被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的肯定结果作为新promise的肯定结果. Promise.prototype.then(onFulfilled, onRejected) 添加肯定和否定回调到当前 promise, 返回一个新的 promise, 将以回调的返回值 来resolve. 浏览器兼容性Desktop Feature Chrome Edge Firefox Internet Explorer Opera Safari Basic Support 32.0 (Yes) 29.0 No 19 7.1 MDN快速链接-Promise]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
</search>
